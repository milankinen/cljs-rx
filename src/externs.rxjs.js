/**********************************************************************
 * Extern for Rx
 * Generated by http://jmmk.github.io/javascript-externs-generator
 **********************************************************************/
var Rx = {
  "AjaxError": {
    "stackTraceLimit": {}
  },
  "AjaxResponse": function () {},
  "AjaxTimeoutError": {
    "stackTraceLimit": {}
  },
  "AnonymousSubject": {
    "ajax": {
      "delete": function () {},
      "get": function () {},
      "getJSON": function () {},
      "patch": function () {},
      "post": function () {},
      "put": function () {}
    },
    "bindCallback": function () {},
    "bindNodeCallback": function () {},
    "combineLatest": function () {},
    "concat": function () {},
    "create": function () {},
    "defer": function () {},
    "empty": function () {},
    "forkJoin": function () {},
    "from": function () {},
    "fromEvent": function () {},
    "fromEventPattern": function () {},
    "fromPromise": function () {},
    "generate": function () {},
    "if": function () {},
    "interval": function () {},
    "merge": function () {},
    "never": function () {},
    "of": function () {},
    "onErrorResumeNext": function () {},
    "pairs": function () {},
    "race": function () {},
    "range": function () {},
    "throw": function () {},
    "timer": function () {},
    "using": function () {},
    "webSocket": function () {},
    "zip": function () {}
  },
  "ArgumentOutOfRangeError": {
    "stackTraceLimit": {}
  },
  "AsyncSubject": {
    "ajax": {
      "delete": function () {},
      "get": function () {},
      "getJSON": function () {},
      "patch": function () {},
      "post": function () {},
      "put": function () {}
    },
    "bindCallback": function () {},
    "bindNodeCallback": function () {},
    "combineLatest": function () {},
    "concat": function () {},
    "create": function () {},
    "defer": function () {},
    "empty": function () {},
    "forkJoin": function () {},
    "from": function () {},
    "fromEvent": function () {},
    "fromEventPattern": function () {},
    "fromPromise": function () {},
    "generate": function () {},
    "if": function () {},
    "interval": function () {},
    "merge": function () {},
    "never": function () {},
    "of": function () {},
    "onErrorResumeNext": function () {},
    "pairs": function () {},
    "race": function () {},
    "range": function () {},
    "throw": function () {},
    "timer": function () {},
    "using": function () {},
    "webSocket": function () {},
    "zip": function () {}
  },
  "BehaviorSubject": {
    "ajax": {
      "delete": function () {},
      "get": function () {},
      "getJSON": function () {},
      "patch": function () {},
      "post": function () {},
      "put": function () {}
    },
    "bindCallback": function () {},
    "bindNodeCallback": function () {},
    "combineLatest": function () {},
    "concat": function () {},
    "create": function () {},
    "defer": function () {},
    "empty": function () {},
    "forkJoin": function () {},
    "from": function () {},
    "fromEvent": function () {},
    "fromEventPattern": function () {},
    "fromPromise": function () {},
    "generate": function () {},
    "if": function () {},
    "interval": function () {},
    "merge": function () {},
    "never": function () {},
    "of": function () {},
    "onErrorResumeNext": function () {},
    "pairs": function () {},
    "race": function () {},
    "range": function () {},
    "throw": function () {},
    "timer": function () {},
    "using": function () {},
    "webSocket": function () {},
    "zip": function () {}
  },
  "ConnectableObservable": {
    "ajax": {
      "delete": function () {},
      "get": function () {},
      "getJSON": function () {},
      "patch": function () {},
      "post": function () {},
      "put": function () {}
    },
    "bindCallback": function () {},
    "bindNodeCallback": function () {},
    "combineLatest": function () {},
    "concat": function () {},
    "create": function () {},
    "defer": function () {},
    "empty": function () {},
    "forkJoin": function () {},
    "from": function () {},
    "fromEvent": function () {},
    "fromEventPattern": function () {},
    "fromPromise": function () {},
    "generate": function () {},
    "if": function () {},
    "interval": function () {},
    "merge": function () {},
    "never": function () {},
    "of": function () {},
    "onErrorResumeNext": function () {},
    "pairs": function () {},
    "race": function () {},
    "range": function () {},
    "throw": function () {},
    "timer": function () {},
    "using": function () {},
    "webSocket": function () {},
    "zip": function () {}
  },
  "EmptyError": {
    "stackTraceLimit": {}
  },
  "Notification": {
    "completeNotification": {
      "accept": function () {},
      "do": function () {},
      "error": {},
      "hasValue": {},
      "kind": {},
      "observe": function () {},
      "toObservable": function () {},
      "value": {}
    },
    "createComplete": function () {},
    "createError": function () {},
    "createNext": function () {},
    "undefinedValueNotification": {
      "accept": function () {},
      "do": function () {},
      "error": {},
      "hasValue": {},
      "kind": {},
      "observe": function () {},
      "toObservable": function () {},
      "value": {}
    }
  },
  "ObjectUnsubscribedError": {
    "stackTraceLimit": {}
  },
  "Observable": {
    "ajax": {
      "delete": function () {},
      "get": function () {},
      "getJSON": function () {},
      "patch": function () {},
      "post": function () {},
      "put": function () {}
    },
    "bindCallback": function () {},
    "bindNodeCallback": function () {},
    "combineLatest": function () {},
    "concat": function () {},
    "create": function () {},
    "defer": function () {},
    "empty": function () {},
    "forkJoin": function () {},
    "from": function () {},
    "fromEvent": function () {},
    "fromEventPattern": function () {},
    "fromPromise": function () {},
    "generate": function () {},
    "if": function () {},
    "interval": function () {},
    "merge": function () {},
    "never": function () {},
    "of": function () {},
    "onErrorResumeNext": function () {},
    "pairs": function () {},
    "race": function () {},
    "range": function () {},
    "throw": function () {},
    "timer": function () {},
    "using": function () {},
    "webSocket": function () {},
    "zip": function () {}
  },
  "ReplaySubject": {
    "ajax": {
      "delete": function () {},
      "get": function () {},
      "getJSON": function () {},
      "patch": function () {},
      "post": function () {},
      "put": function () {}
    },
    "bindCallback": function () {},
    "bindNodeCallback": function () {},
    "combineLatest": function () {},
    "concat": function () {},
    "create": function () {},
    "defer": function () {},
    "empty": function () {},
    "forkJoin": function () {},
    "from": function () {},
    "fromEvent": function () {},
    "fromEventPattern": function () {},
    "fromPromise": function () {},
    "generate": function () {},
    "if": function () {},
    "interval": function () {},
    "merge": function () {},
    "never": function () {},
    "of": function () {},
    "onErrorResumeNext": function () {},
    "pairs": function () {},
    "race": function () {},
    "range": function () {},
    "throw": function () {},
    "timer": function () {},
    "using": function () {},
    "webSocket": function () {},
    "zip": function () {}
  },
  "Scheduler": {
    "animationFrame": {
      "SchedulerAction": {
        "EMPTY": {
          "_addParent": function () {},
          "_parent": {},
          "_parents": {},
          "_subscriptions": {},
          "add": function () {},
          "closed": {},
          "remove": function () {},
          "unsubscribe": function () {}
        }
      },
      "actions": {},
      "active": {},
      "constructor": {
        "now": function () {}
      },
      "flush": function () {},
      "now": function () {},
      "schedule": function () {},
      "scheduled": {}
    },
    "asap": {
      "SchedulerAction": {
        "EMPTY": {
          "_addParent": function () {},
          "_parent": {},
          "_parents": {},
          "_subscriptions": {},
          "add": function () {},
          "closed": {},
          "remove": function () {},
          "unsubscribe": function () {}
        }
      },
      "actions": {},
      "active": {},
      "constructor": {
        "now": function () {}
      },
      "flush": function () {},
      "now": function () {},
      "schedule": function () {},
      "scheduled": {}
    },
    "async": {
      "SchedulerAction": {
        "EMPTY": {
          "_addParent": function () {},
          "_parent": {},
          "_parents": {},
          "_subscriptions": {},
          "add": function () {},
          "closed": {},
          "remove": function () {},
          "unsubscribe": function () {}
        }
      },
      "actions": {},
      "active": {},
      "constructor": {
        "now": function () {}
      },
      "flush": function () {},
      "now": function () {},
      "schedule": function () {},
      "scheduled": {}
    },
    "queue": {
      "SchedulerAction": {
        "EMPTY": {
          "_addParent": function () {},
          "_parent": {},
          "_parents": {},
          "_subscriptions": {},
          "add": function () {},
          "closed": {},
          "remove": function () {},
          "unsubscribe": function () {}
        }
      },
      "actions": {},
      "active": {},
      "constructor": {
        "now": function () {}
      },
      "flush": function () {},
      "now": function () {},
      "schedule": function () {},
      "scheduled": {}
    }
  },
  "Subject": {
    "ajax": {
      "delete": function () {},
      "get": function () {},
      "getJSON": function () {},
      "patch": function () {},
      "post": function () {},
      "put": function () {}
    },
    "bindCallback": function () {},
    "bindNodeCallback": function () {},
    "combineLatest": function () {},
    "concat": function () {},
    "create": function () {},
    "defer": function () {},
    "empty": function () {},
    "forkJoin": function () {},
    "from": function () {},
    "fromEvent": function () {},
    "fromEventPattern": function () {},
    "fromPromise": function () {},
    "generate": function () {},
    "if": function () {},
    "interval": function () {},
    "merge": function () {},
    "never": function () {},
    "of": function () {},
    "onErrorResumeNext": function () {},
    "pairs": function () {},
    "race": function () {},
    "range": function () {},
    "throw": function () {},
    "timer": function () {},
    "using": function () {},
    "webSocket": function () {},
    "zip": function () {}
  },
  "Subscriber": {
    "EMPTY": {
      "_addParent": function () {},
      "_parent": {},
      "_parents": {},
      "_subscriptions": {},
      "add": function () {},
      "closed": {},
      "remove": function () {},
      "unsubscribe": function () {}
    },
    "create": function () {}
  },
  "Subscription": {
    "EMPTY": {
      "_addParent": function () {},
      "_parent": {},
      "_parents": {},
      "_subscriptions": {},
      "add": function () {},
      "closed": {},
      "remove": function () {},
      "unsubscribe": function () {}
    }
  },
  "Symbol": {
    "iterator": {},
    "observable": {},
    "rxSubscriber": {}
  },
  "TestScheduler": {
    "frameTimeFactor": {},
    "now": function () {},
    "parseMarbles": function () {},
    "parseMarblesAsSubscriptions": function () {}
  },
  "TimeInterval": function () {},
  "TimeoutError": {
    "stackTraceLimit": {}
  },
  "Timestamp": function () {},
  "UnsubscriptionError": {
    "stackTraceLimit": {}
  },
  "VirtualTimeScheduler": {
    "frameTimeFactor": {},
    "now": function () {}
  },
  "operators": {
    "audit": function () {},
    "auditTime": function () {},
    "buffer": function () {},
    "bufferCount": function () {},
    "bufferTime": function () {},
    "bufferToggle": function () {},
    "bufferWhen": function () {},
    "catchError": function () {},
    "combineAll": function () {},
    "combineLatest": function () {},
    "concat": function () {},
    "concatAll": function () {},
    "concatMap": function () {},
    "concatMapTo": function () {},
    "count": function () {},
    "debounce": function () {},
    "debounceTime": function () {},
    "defaultIfEmpty": function () {},
    "delay": function () {},
    "delayWhen": function () {},
    "dematerialize": function () {},
    "distinct": function () {},
    "distinctUntilChanged": function () {},
    "distinctUntilKeyChanged": function () {},
    "elementAt": function () {},
    "every": function () {},
    "exhaust": function () {},
    "exhaustMap": function () {},
    "expand": function () {},
    "filter": function () {},
    "finalize": function () {},
    "find": function () {},
    "findIndex": function () {},
    "first": function () {},
    "flatMap": function () {},
    "groupBy": function () {},
    "ignoreElements": function () {},
    "isEmpty": function () {},
    "last": function () {},
    "map": function () {},
    "mapTo": function () {},
    "materialize": function () {},
    "max": function () {},
    "merge": function () {},
    "mergeAll": function () {},
    "mergeMap": function () {},
    "mergeMapTo": function () {},
    "mergeScan": function () {},
    "min": function () {},
    "multicast": function () {},
    "observeOn": function () {},
    "onErrorResumeNext": function () {},
    "pairwise": function () {},
    "partition": function () {},
    "pluck": function () {},
    "publish": function () {},
    "publishBehavior": function () {},
    "publishLast": function () {},
    "publishReplay": function () {},
    "race": function () {},
    "reduce": function () {},
    "refCount": function () {},
    "repeat": function () {},
    "repeatWhen": function () {},
    "retry": function () {},
    "retryWhen": function () {},
    "sample": function () {},
    "sampleTime": function () {},
    "scan": function () {},
    "sequenceEqual": function () {},
    "share": function () {},
    "shareReplay": function () {},
    "single": function () {},
    "skip": function () {},
    "skipLast": function () {},
    "skipUntil": function () {},
    "skipWhile": function () {},
    "startWith": function () {},
    "switchAll": function () {},
    "switchMap": function () {},
    "switchMapTo": function () {},
    "take": function () {},
    "takeLast": function () {},
    "takeUntil": function () {},
    "takeWhile": function () {},
    "tap": function () {},
    "throttle": function () {},
    "throttleTime": function () {},
    "timeInterval": function () {},
    "timeout": function () {},
    "timeoutWith": function () {},
    "timestamp": function () {},
    "toArray": function () {},
    "window": function () {},
    "windowCount": function () {},
    "windowTime": function () {},
    "windowToggle": function () {},
    "windowWhen": function () {},
    "withLatestFrom": function () {},
    "zip": function () {},
    "zipAll": function () {}
  },
  "pipe": function () {}
};
Rx.AjaxError.prototype = {
  "constructor": function () {}
};
Rx.AjaxTimeoutError.prototype = {
  "constructor": function () {}
};
Rx.AnonymousSubject.prototype = {
  "_catch": function () {},
  "_do": function () {},
  "_finally": function () {},
  "_subscribe": function () {},
  "_switch": function () {},
  "_trySubscribe": function () {},
  "asObservable": function () {},
  "audit": function () {},
  "auditTime": function () {},
  "buffer": function () {},
  "bufferCount": function () {},
  "bufferTime": function () {},
  "bufferToggle": function () {},
  "bufferWhen": function () {},
  "catch": function () {},
  "combineAll": function () {},
  "combineLatest": function () {},
  "complete": function () {},
  "concat": function () {},
  "concatAll": function () {},
  "concatMap": function () {},
  "concatMapTo": function () {},
  "constructor": function () {},
  "count": function () {},
  "debounce": function () {},
  "debounceTime": function () {},
  "defaultIfEmpty": function () {},
  "delay": function () {},
  "delayWhen": function () {},
  "dematerialize": function () {},
  "distinct": function () {},
  "distinctUntilChanged": function () {},
  "distinctUntilKeyChanged": function () {},
  "do": function () {},
  "elementAt": function () {},
  "error": function () {},
  "every": function () {},
  "exhaust": function () {},
  "exhaustMap": function () {},
  "expand": function () {},
  "filter": function () {},
  "finally": function () {},
  "find": function () {},
  "findIndex": function () {},
  "first": function () {},
  "flatMap": function () {},
  "flatMapTo": function () {},
  "forEach": function () {},
  "groupBy": function () {},
  "ignoreElements": function () {},
  "isEmpty": function () {},
  "last": function () {},
  "let": function () {},
  "letBind": function () {},
  "lift": function () {},
  "map": function () {},
  "mapTo": function () {},
  "materialize": function () {},
  "max": function () {},
  "merge": function () {},
  "mergeAll": function () {},
  "mergeMap": function () {},
  "mergeMapTo": function () {},
  "mergeScan": function () {},
  "min": function () {},
  "multicast": function () {},
  "next": function () {},
  "observeOn": function () {},
  "onErrorResumeNext": function () {},
  "pairwise": function () {},
  "partition": function () {},
  "pipe": function () {},
  "pluck": function () {},
  "publish": function () {},
  "publishBehavior": function () {},
  "publishLast": function () {},
  "publishReplay": function () {},
  "race": function () {},
  "reduce": function () {},
  "repeat": function () {},
  "repeatWhen": function () {},
  "retry": function () {},
  "retryWhen": function () {},
  "sample": function () {},
  "sampleTime": function () {},
  "scan": function () {},
  "sequenceEqual": function () {},
  "share": function () {},
  "shareReplay": function () {},
  "single": function () {},
  "skip": function () {},
  "skipLast": function () {},
  "skipUntil": function () {},
  "skipWhile": function () {},
  "startWith": function () {},
  "subscribe": function () {},
  "subscribeOn": function () {},
  "switch": function () {},
  "switchMap": function () {},
  "switchMapTo": function () {},
  "take": function () {},
  "takeLast": function () {},
  "takeUntil": function () {},
  "takeWhile": function () {},
  "throttle": function () {},
  "throttleTime": function () {},
  "timeInterval": function () {},
  "timeout": function () {},
  "timeoutWith": function () {},
  "timestamp": function () {},
  "toArray": function () {},
  "toPromise": function () {},
  "unsubscribe": function () {},
  "window": function () {},
  "windowCount": function () {},
  "windowTime": function () {},
  "windowToggle": function () {},
  "windowWhen": function () {},
  "withLatestFrom": function () {},
  "zip": function () {},
  "zipAll": function () {}
};
Rx.ArgumentOutOfRangeError.prototype = {
  "constructor": function () {}
};
Rx.AsyncSubject.prototype = {
  "_catch": function () {},
  "_do": function () {},
  "_finally": function () {},
  "_subscribe": function () {},
  "_switch": function () {},
  "_trySubscribe": function () {},
  "asObservable": function () {},
  "audit": function () {},
  "auditTime": function () {},
  "buffer": function () {},
  "bufferCount": function () {},
  "bufferTime": function () {},
  "bufferToggle": function () {},
  "bufferWhen": function () {},
  "catch": function () {},
  "combineAll": function () {},
  "combineLatest": function () {},
  "complete": function () {},
  "concat": function () {},
  "concatAll": function () {},
  "concatMap": function () {},
  "concatMapTo": function () {},
  "constructor": function () {},
  "count": function () {},
  "debounce": function () {},
  "debounceTime": function () {},
  "defaultIfEmpty": function () {},
  "delay": function () {},
  "delayWhen": function () {},
  "dematerialize": function () {},
  "distinct": function () {},
  "distinctUntilChanged": function () {},
  "distinctUntilKeyChanged": function () {},
  "do": function () {},
  "elementAt": function () {},
  "error": function () {},
  "every": function () {},
  "exhaust": function () {},
  "exhaustMap": function () {},
  "expand": function () {},
  "filter": function () {},
  "finally": function () {},
  "find": function () {},
  "findIndex": function () {},
  "first": function () {},
  "flatMap": function () {},
  "flatMapTo": function () {},
  "forEach": function () {},
  "groupBy": function () {},
  "ignoreElements": function () {},
  "isEmpty": function () {},
  "last": function () {},
  "let": function () {},
  "letBind": function () {},
  "lift": function () {},
  "map": function () {},
  "mapTo": function () {},
  "materialize": function () {},
  "max": function () {},
  "merge": function () {},
  "mergeAll": function () {},
  "mergeMap": function () {},
  "mergeMapTo": function () {},
  "mergeScan": function () {},
  "min": function () {},
  "multicast": function () {},
  "next": function () {},
  "observeOn": function () {},
  "onErrorResumeNext": function () {},
  "pairwise": function () {},
  "partition": function () {},
  "pipe": function () {},
  "pluck": function () {},
  "publish": function () {},
  "publishBehavior": function () {},
  "publishLast": function () {},
  "publishReplay": function () {},
  "race": function () {},
  "reduce": function () {},
  "repeat": function () {},
  "repeatWhen": function () {},
  "retry": function () {},
  "retryWhen": function () {},
  "sample": function () {},
  "sampleTime": function () {},
  "scan": function () {},
  "sequenceEqual": function () {},
  "share": function () {},
  "shareReplay": function () {},
  "single": function () {},
  "skip": function () {},
  "skipLast": function () {},
  "skipUntil": function () {},
  "skipWhile": function () {},
  "startWith": function () {},
  "subscribe": function () {},
  "subscribeOn": function () {},
  "switch": function () {},
  "switchMap": function () {},
  "switchMapTo": function () {},
  "take": function () {},
  "takeLast": function () {},
  "takeUntil": function () {},
  "takeWhile": function () {},
  "throttle": function () {},
  "throttleTime": function () {},
  "timeInterval": function () {},
  "timeout": function () {},
  "timeoutWith": function () {},
  "timestamp": function () {},
  "toArray": function () {},
  "toPromise": function () {},
  "unsubscribe": function () {},
  "window": function () {},
  "windowCount": function () {},
  "windowTime": function () {},
  "windowToggle": function () {},
  "windowWhen": function () {},
  "withLatestFrom": function () {},
  "zip": function () {},
  "zipAll": function () {}
};
Rx.BehaviorSubject.prototype = {
  "_catch": function () {},
  "_do": function () {},
  "_finally": function () {},
  "_subscribe": function () {},
  "_switch": function () {},
  "_trySubscribe": function () {},
  "asObservable": function () {},
  "audit": function () {},
  "auditTime": function () {},
  "buffer": function () {},
  "bufferCount": function () {},
  "bufferTime": function () {},
  "bufferToggle": function () {},
  "bufferWhen": function () {},
  "catch": function () {},
  "combineAll": function () {},
  "combineLatest": function () {},
  "complete": function () {},
  "concat": function () {},
  "concatAll": function () {},
  "concatMap": function () {},
  "concatMapTo": function () {},
  "constructor": function () {},
  "count": function () {},
  "debounce": function () {},
  "debounceTime": function () {},
  "defaultIfEmpty": function () {},
  "delay": function () {},
  "delayWhen": function () {},
  "dematerialize": function () {},
  "distinct": function () {},
  "distinctUntilChanged": function () {},
  "distinctUntilKeyChanged": function () {},
  "do": function () {},
  "elementAt": function () {},
  "error": function () {},
  "every": function () {},
  "exhaust": function () {},
  "exhaustMap": function () {},
  "expand": function () {},
  "filter": function () {},
  "finally": function () {},
  "find": function () {},
  "findIndex": function () {},
  "first": function () {},
  "flatMap": function () {},
  "flatMapTo": function () {},
  "forEach": function () {},
  "getValue": function () {},
  "groupBy": function () {},
  "ignoreElements": function () {},
  "isEmpty": function () {},
  "last": function () {},
  "let": function () {},
  "letBind": function () {},
  "lift": function () {},
  "map": function () {},
  "mapTo": function () {},
  "materialize": function () {},
  "max": function () {},
  "merge": function () {},
  "mergeAll": function () {},
  "mergeMap": function () {},
  "mergeMapTo": function () {},
  "mergeScan": function () {},
  "min": function () {},
  "multicast": function () {},
  "next": function () {},
  "observeOn": function () {},
  "onErrorResumeNext": function () {},
  "pairwise": function () {},
  "partition": function () {},
  "pipe": function () {},
  "pluck": function () {},
  "publish": function () {},
  "publishBehavior": function () {},
  "publishLast": function () {},
  "publishReplay": function () {},
  "race": function () {},
  "reduce": function () {},
  "repeat": function () {},
  "repeatWhen": function () {},
  "retry": function () {},
  "retryWhen": function () {},
  "sample": function () {},
  "sampleTime": function () {},
  "scan": function () {},
  "sequenceEqual": function () {},
  "share": function () {},
  "shareReplay": function () {},
  "single": function () {},
  "skip": function () {},
  "skipLast": function () {},
  "skipUntil": function () {},
  "skipWhile": function () {},
  "startWith": function () {},
  "subscribe": function () {},
  "subscribeOn": function () {},
  "switch": function () {},
  "switchMap": function () {},
  "switchMapTo": function () {},
  "take": function () {},
  "takeLast": function () {},
  "takeUntil": function () {},
  "takeWhile": function () {},
  "throttle": function () {},
  "throttleTime": function () {},
  "timeInterval": function () {},
  "timeout": function () {},
  "timeoutWith": function () {},
  "timestamp": function () {},
  "toArray": function () {},
  "toPromise": function () {},
  "unsubscribe": function () {},
  "value": function () {},
  "window": function () {},
  "windowCount": function () {},
  "windowTime": function () {},
  "windowToggle": function () {},
  "windowWhen": function () {},
  "withLatestFrom": function () {},
  "zip": function () {},
  "zipAll": function () {}
};
Rx.ConnectableObservable.prototype = {
  "_catch": function () {},
  "_do": function () {},
  "_finally": function () {},
  "_subscribe": function () {},
  "_switch": function () {},
  "_trySubscribe": function () {},
  "audit": function () {},
  "auditTime": function () {},
  "buffer": function () {},
  "bufferCount": function () {},
  "bufferTime": function () {},
  "bufferToggle": function () {},
  "bufferWhen": function () {},
  "catch": function () {},
  "combineAll": function () {},
  "combineLatest": function () {},
  "concat": function () {},
  "concatAll": function () {},
  "concatMap": function () {},
  "concatMapTo": function () {},
  "connect": function () {},
  "constructor": function () {},
  "count": function () {},
  "debounce": function () {},
  "debounceTime": function () {},
  "defaultIfEmpty": function () {},
  "delay": function () {},
  "delayWhen": function () {},
  "dematerialize": function () {},
  "distinct": function () {},
  "distinctUntilChanged": function () {},
  "distinctUntilKeyChanged": function () {},
  "do": function () {},
  "elementAt": function () {},
  "every": function () {},
  "exhaust": function () {},
  "exhaustMap": function () {},
  "expand": function () {},
  "filter": function () {},
  "finally": function () {},
  "find": function () {},
  "findIndex": function () {},
  "first": function () {},
  "flatMap": function () {},
  "flatMapTo": function () {},
  "forEach": function () {},
  "getSubject": function () {},
  "groupBy": function () {},
  "ignoreElements": function () {},
  "isEmpty": function () {},
  "last": function () {},
  "let": function () {},
  "letBind": function () {},
  "lift": function () {},
  "map": function () {},
  "mapTo": function () {},
  "materialize": function () {},
  "max": function () {},
  "merge": function () {},
  "mergeAll": function () {},
  "mergeMap": function () {},
  "mergeMapTo": function () {},
  "mergeScan": function () {},
  "min": function () {},
  "multicast": function () {},
  "observeOn": function () {},
  "onErrorResumeNext": function () {},
  "pairwise": function () {},
  "partition": function () {},
  "pipe": function () {},
  "pluck": function () {},
  "publish": function () {},
  "publishBehavior": function () {},
  "publishLast": function () {},
  "publishReplay": function () {},
  "race": function () {},
  "reduce": function () {},
  "refCount": function () {},
  "repeat": function () {},
  "repeatWhen": function () {},
  "retry": function () {},
  "retryWhen": function () {},
  "sample": function () {},
  "sampleTime": function () {},
  "scan": function () {},
  "sequenceEqual": function () {},
  "share": function () {},
  "shareReplay": function () {},
  "single": function () {},
  "skip": function () {},
  "skipLast": function () {},
  "skipUntil": function () {},
  "skipWhile": function () {},
  "startWith": function () {},
  "subscribe": function () {},
  "subscribeOn": function () {},
  "switch": function () {},
  "switchMap": function () {},
  "switchMapTo": function () {},
  "take": function () {},
  "takeLast": function () {},
  "takeUntil": function () {},
  "takeWhile": function () {},
  "throttle": function () {},
  "throttleTime": function () {},
  "timeInterval": function () {},
  "timeout": function () {},
  "timeoutWith": function () {},
  "timestamp": function () {},
  "toArray": function () {},
  "toPromise": function () {},
  "window": function () {},
  "windowCount": function () {},
  "windowTime": function () {},
  "windowToggle": function () {},
  "windowWhen": function () {},
  "withLatestFrom": function () {},
  "zip": function () {},
  "zipAll": function () {}
};
Rx.EmptyError.prototype = {
  "constructor": function () {}
};
Rx.Notification.prototype = {
  "accept": function () {},
  "do": function () {},
  "observe": function () {},
  "toObservable": function () {}
};
Rx.ObjectUnsubscribedError.prototype = {
  "constructor": function () {}
};
Rx.Observable.prototype = {
  "_catch": function () {},
  "_do": function () {},
  "_finally": function () {},
  "_subscribe": function () {},
  "_switch": function () {},
  "_trySubscribe": function () {},
  "audit": function () {},
  "auditTime": function () {},
  "buffer": function () {},
  "bufferCount": function () {},
  "bufferTime": function () {},
  "bufferToggle": function () {},
  "bufferWhen": function () {},
  "catch": function () {},
  "combineAll": function () {},
  "combineLatest": function () {},
  "concat": function () {},
  "concatAll": function () {},
  "concatMap": function () {},
  "concatMapTo": function () {},
  "count": function () {},
  "debounce": function () {},
  "debounceTime": function () {},
  "defaultIfEmpty": function () {},
  "delay": function () {},
  "delayWhen": function () {},
  "dematerialize": function () {},
  "distinct": function () {},
  "distinctUntilChanged": function () {},
  "distinctUntilKeyChanged": function () {},
  "do": function () {},
  "elementAt": function () {},
  "every": function () {},
  "exhaust": function () {},
  "exhaustMap": function () {},
  "expand": function () {},
  "filter": function () {},
  "finally": function () {},
  "find": function () {},
  "findIndex": function () {},
  "first": function () {},
  "flatMap": function () {},
  "flatMapTo": function () {},
  "forEach": function () {},
  "groupBy": function () {},
  "ignoreElements": function () {},
  "isEmpty": function () {},
  "last": function () {},
  "let": function () {},
  "letBind": function () {},
  "lift": function () {},
  "map": function () {},
  "mapTo": function () {},
  "materialize": function () {},
  "max": function () {},
  "merge": function () {},
  "mergeAll": function () {},
  "mergeMap": function () {},
  "mergeMapTo": function () {},
  "mergeScan": function () {},
  "min": function () {},
  "multicast": function () {},
  "observeOn": function () {},
  "onErrorResumeNext": function () {},
  "pairwise": function () {},
  "partition": function () {},
  "pipe": function () {},
  "pluck": function () {},
  "publish": function () {},
  "publishBehavior": function () {},
  "publishLast": function () {},
  "publishReplay": function () {},
  "race": function () {},
  "reduce": function () {},
  "repeat": function () {},
  "repeatWhen": function () {},
  "retry": function () {},
  "retryWhen": function () {},
  "sample": function () {},
  "sampleTime": function () {},
  "scan": function () {},
  "sequenceEqual": function () {},
  "share": function () {},
  "shareReplay": function () {},
  "single": function () {},
  "skip": function () {},
  "skipLast": function () {},
  "skipUntil": function () {},
  "skipWhile": function () {},
  "startWith": function () {},
  "subscribe": function () {},
  "subscribeOn": function () {},
  "switch": function () {},
  "switchMap": function () {},
  "switchMapTo": function () {},
  "take": function () {},
  "takeLast": function () {},
  "takeUntil": function () {},
  "takeWhile": function () {},
  "throttle": function () {},
  "throttleTime": function () {},
  "timeInterval": function () {},
  "timeout": function () {},
  "timeoutWith": function () {},
  "timestamp": function () {},
  "toArray": function () {},
  "toPromise": function () {},
  "window": function () {},
  "windowCount": function () {},
  "windowTime": function () {},
  "windowToggle": function () {},
  "windowWhen": function () {},
  "withLatestFrom": function () {},
  "zip": function () {},
  "zipAll": function () {}
};
Rx.ReplaySubject.prototype = {
  "_catch": function () {},
  "_do": function () {},
  "_finally": function () {},
  "_getNow": function () {},
  "_subscribe": function () {},
  "_switch": function () {},
  "_trimBufferThenGetEvents": function () {},
  "_trySubscribe": function () {},
  "asObservable": function () {},
  "audit": function () {},
  "auditTime": function () {},
  "buffer": function () {},
  "bufferCount": function () {},
  "bufferTime": function () {},
  "bufferToggle": function () {},
  "bufferWhen": function () {},
  "catch": function () {},
  "combineAll": function () {},
  "combineLatest": function () {},
  "complete": function () {},
  "concat": function () {},
  "concatAll": function () {},
  "concatMap": function () {},
  "concatMapTo": function () {},
  "constructor": function () {},
  "count": function () {},
  "debounce": function () {},
  "debounceTime": function () {},
  "defaultIfEmpty": function () {},
  "delay": function () {},
  "delayWhen": function () {},
  "dematerialize": function () {},
  "distinct": function () {},
  "distinctUntilChanged": function () {},
  "distinctUntilKeyChanged": function () {},
  "do": function () {},
  "elementAt": function () {},
  "error": function () {},
  "every": function () {},
  "exhaust": function () {},
  "exhaustMap": function () {},
  "expand": function () {},
  "filter": function () {},
  "finally": function () {},
  "find": function () {},
  "findIndex": function () {},
  "first": function () {},
  "flatMap": function () {},
  "flatMapTo": function () {},
  "forEach": function () {},
  "groupBy": function () {},
  "ignoreElements": function () {},
  "isEmpty": function () {},
  "last": function () {},
  "let": function () {},
  "letBind": function () {},
  "lift": function () {},
  "map": function () {},
  "mapTo": function () {},
  "materialize": function () {},
  "max": function () {},
  "merge": function () {},
  "mergeAll": function () {},
  "mergeMap": function () {},
  "mergeMapTo": function () {},
  "mergeScan": function () {},
  "min": function () {},
  "multicast": function () {},
  "next": function () {},
  "observeOn": function () {},
  "onErrorResumeNext": function () {},
  "pairwise": function () {},
  "partition": function () {},
  "pipe": function () {},
  "pluck": function () {},
  "publish": function () {},
  "publishBehavior": function () {},
  "publishLast": function () {},
  "publishReplay": function () {},
  "race": function () {},
  "reduce": function () {},
  "repeat": function () {},
  "repeatWhen": function () {},
  "retry": function () {},
  "retryWhen": function () {},
  "sample": function () {},
  "sampleTime": function () {},
  "scan": function () {},
  "sequenceEqual": function () {},
  "share": function () {},
  "shareReplay": function () {},
  "single": function () {},
  "skip": function () {},
  "skipLast": function () {},
  "skipUntil": function () {},
  "skipWhile": function () {},
  "startWith": function () {},
  "subscribe": function () {},
  "subscribeOn": function () {},
  "switch": function () {},
  "switchMap": function () {},
  "switchMapTo": function () {},
  "take": function () {},
  "takeLast": function () {},
  "takeUntil": function () {},
  "takeWhile": function () {},
  "throttle": function () {},
  "throttleTime": function () {},
  "timeInterval": function () {},
  "timeout": function () {},
  "timeoutWith": function () {},
  "timestamp": function () {},
  "toArray": function () {},
  "toPromise": function () {},
  "unsubscribe": function () {},
  "window": function () {},
  "windowCount": function () {},
  "windowTime": function () {},
  "windowToggle": function () {},
  "windowWhen": function () {},
  "withLatestFrom": function () {},
  "zip": function () {},
  "zipAll": function () {}
};
Rx.Scheduler.animationFrame.SchedulerAction.prototype = {
  "_addParent": function () {},
  "_execute": function () {},
  "_unsubscribe": function () {},
  "add": function () {},
  "constructor": function () {},
  "execute": function () {},
  "recycleAsyncId": function () {},
  "remove": function () {},
  "requestAsyncId": function () {},
  "schedule": function () {},
  "unsubscribe": function () {}
};
Rx.Scheduler.animationFrame.constructor.prototype = {
  "constructor": function () {},
  "flush": function () {},
  "schedule": function () {}
};
Rx.Scheduler.asap.SchedulerAction.prototype = {
  "_addParent": function () {},
  "_execute": function () {},
  "_unsubscribe": function () {},
  "add": function () {},
  "constructor": function () {},
  "execute": function () {},
  "recycleAsyncId": function () {},
  "remove": function () {},
  "requestAsyncId": function () {},
  "schedule": function () {},
  "unsubscribe": function () {}
};
Rx.Scheduler.asap.constructor.prototype = {
  "constructor": function () {},
  "flush": function () {},
  "schedule": function () {}
};
Rx.Scheduler.async.SchedulerAction.prototype = {
  "_addParent": function () {},
  "_execute": function () {},
  "_unsubscribe": function () {},
  "add": function () {},
  "constructor": function () {},
  "execute": function () {},
  "recycleAsyncId": function () {},
  "remove": function () {},
  "requestAsyncId": function () {},
  "schedule": function () {},
  "unsubscribe": function () {}
};
Rx.Scheduler.async.constructor.prototype = {
  "constructor": function () {},
  "flush": function () {},
  "schedule": function () {}
};
Rx.Scheduler.queue.SchedulerAction.prototype = {
  "_addParent": function () {},
  "_execute": function () {},
  "_unsubscribe": function () {},
  "add": function () {},
  "constructor": function () {},
  "execute": function () {},
  "recycleAsyncId": function () {},
  "remove": function () {},
  "requestAsyncId": function () {},
  "schedule": function () {},
  "unsubscribe": function () {}
};
Rx.Scheduler.queue.constructor.prototype = {
  "constructor": function () {},
  "flush": function () {},
  "schedule": function () {}
};
Rx.Subject.prototype = {
  "_catch": function () {},
  "_do": function () {},
  "_finally": function () {},
  "_subscribe": function () {},
  "_switch": function () {},
  "_trySubscribe": function () {},
  "asObservable": function () {},
  "audit": function () {},
  "auditTime": function () {},
  "buffer": function () {},
  "bufferCount": function () {},
  "bufferTime": function () {},
  "bufferToggle": function () {},
  "bufferWhen": function () {},
  "catch": function () {},
  "combineAll": function () {},
  "combineLatest": function () {},
  "complete": function () {},
  "concat": function () {},
  "concatAll": function () {},
  "concatMap": function () {},
  "concatMapTo": function () {},
  "constructor": function () {},
  "count": function () {},
  "debounce": function () {},
  "debounceTime": function () {},
  "defaultIfEmpty": function () {},
  "delay": function () {},
  "delayWhen": function () {},
  "dematerialize": function () {},
  "distinct": function () {},
  "distinctUntilChanged": function () {},
  "distinctUntilKeyChanged": function () {},
  "do": function () {},
  "elementAt": function () {},
  "error": function () {},
  "every": function () {},
  "exhaust": function () {},
  "exhaustMap": function () {},
  "expand": function () {},
  "filter": function () {},
  "finally": function () {},
  "find": function () {},
  "findIndex": function () {},
  "first": function () {},
  "flatMap": function () {},
  "flatMapTo": function () {},
  "forEach": function () {},
  "groupBy": function () {},
  "ignoreElements": function () {},
  "isEmpty": function () {},
  "last": function () {},
  "let": function () {},
  "letBind": function () {},
  "lift": function () {},
  "map": function () {},
  "mapTo": function () {},
  "materialize": function () {},
  "max": function () {},
  "merge": function () {},
  "mergeAll": function () {},
  "mergeMap": function () {},
  "mergeMapTo": function () {},
  "mergeScan": function () {},
  "min": function () {},
  "multicast": function () {},
  "next": function () {},
  "observeOn": function () {},
  "onErrorResumeNext": function () {},
  "pairwise": function () {},
  "partition": function () {},
  "pipe": function () {},
  "pluck": function () {},
  "publish": function () {},
  "publishBehavior": function () {},
  "publishLast": function () {},
  "publishReplay": function () {},
  "race": function () {},
  "reduce": function () {},
  "repeat": function () {},
  "repeatWhen": function () {},
  "retry": function () {},
  "retryWhen": function () {},
  "sample": function () {},
  "sampleTime": function () {},
  "scan": function () {},
  "sequenceEqual": function () {},
  "share": function () {},
  "shareReplay": function () {},
  "single": function () {},
  "skip": function () {},
  "skipLast": function () {},
  "skipUntil": function () {},
  "skipWhile": function () {},
  "startWith": function () {},
  "subscribe": function () {},
  "subscribeOn": function () {},
  "switch": function () {},
  "switchMap": function () {},
  "switchMapTo": function () {},
  "take": function () {},
  "takeLast": function () {},
  "takeUntil": function () {},
  "takeWhile": function () {},
  "throttle": function () {},
  "throttleTime": function () {},
  "timeInterval": function () {},
  "timeout": function () {},
  "timeoutWith": function () {},
  "timestamp": function () {},
  "toArray": function () {},
  "toPromise": function () {},
  "unsubscribe": function () {},
  "window": function () {},
  "windowCount": function () {},
  "windowTime": function () {},
  "windowToggle": function () {},
  "windowWhen": function () {},
  "withLatestFrom": function () {},
  "zip": function () {},
  "zipAll": function () {}
};
Rx.Subscriber.prototype = {
  "_addParent": function () {},
  "_complete": function () {},
  "_error": function () {},
  "_next": function () {},
  "_unsubscribeAndRecycle": function () {},
  "add": function () {},
  "complete": function () {},
  "constructor": function () {},
  "error": function () {},
  "next": function () {},
  "remove": function () {},
  "unsubscribe": function () {}
};
Rx.Subscription.prototype = {
  "_addParent": function () {},
  "add": function () {},
  "remove": function () {},
  "unsubscribe": function () {}
};
Rx.TestScheduler.prototype = {
  "constructor": function () {},
  "createColdObservable": function () {},
  "createHotObservable": function () {},
  "createTime": function () {},
  "expectObservable": function () {},
  "expectSubscriptions": function () {},
  "flush": function () {},
  "materializeInnerObservable": function () {},
  "schedule": function () {}
};
Rx.TimeoutError.prototype = {
  "constructor": function () {}
};
Rx.UnsubscriptionError.prototype = {
  "constructor": function () {}
};
Rx.VirtualTimeScheduler.prototype = {
  "constructor": function () {},
  "flush": function () {},
  "schedule": function () {}
};
/**********************************************************************
 * End Generated Extern for Rx
 /**********************************************************************/